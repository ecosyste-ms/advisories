module Osv
  class VulnerabilityTransformer
    ECOSYSTEM_MAPPING = {
      'npm' => 'npm',
      'pypi' => 'PyPI',
      'rubygems' => 'RubyGems',
      'maven' => 'Maven',
      'nuget' => 'NuGet',
      'go' => 'Go',
      'cargo' => 'crates.io',
      'packagist' => 'Packagist',
      'hex' => 'Hex',
      'pub' => 'Pub',
      'actions' => 'GitHub Actions',
      'cran' => 'CRAN',
      'ghc' => 'GHC',
      'hackage' => 'Hackage',
      'julia' => 'Julia',
      'swift' => 'SwiftURL',
      'debian' => 'Debian',
      'alpine' => 'Alpine',
      'ubuntu' => 'Ubuntu',
      'almalinux' => 'AlmaLinux',
      'rocky' => 'Rocky Linux',
      'suse' => 'SUSE',
      'opensuse' => 'openSUSE',
      'redhat' => 'Red Hat',
      'mageia' => 'Mageia',
      'openeuler' => 'openEuler',
      'wolfi' => 'Wolfi',
      'chainguard' => 'Chainguard',
      'bitnami' => 'Bitnami',
      'android' => 'Android',
      'linux' => 'Linux',
      'oss-fuzz' => 'OSS-Fuzz',
      'git' => 'GIT'
    }.freeze

    SUMMARY_MAX_LENGTH = 120

    attr_reader :advisory

    def initialize(advisory)
      @advisory = advisory
    end

    def transform(summary_only: false)
      if summary_only
        summary_format
      else
        full_format
      end
    end

    def summary_format
      {
        id: advisory.uuid,
        modified: format_timestamp(advisory.updated_at)
      }
    end

    def full_format
      result = {
        id: advisory.uuid,
        summary: truncate_summary(advisory.title),
        details: advisory.description,
        aliases: build_aliases,
        modified: format_timestamp(advisory.updated_at),
        published: format_timestamp(advisory.published_at),
        references: build_references,
        affected: build_affected,
        database_specific: build_database_specific
      }

      result[:withdrawn] = format_timestamp(advisory.withdrawn_at) if advisory.withdrawn_at.present?
      result[:severity] = build_severity if advisory.cvss_vector.present?

      result
    end

    def build_aliases
      advisory.identifiers.reject { |id| id == advisory.uuid }
    end

    def truncate_summary(title)
      return nil if title.blank?
      return title if title.length <= SUMMARY_MAX_LENGTH
      title[0, SUMMARY_MAX_LENGTH - 3] + '...'
    end

    def build_references
      return [] if advisory.references.blank?

      advisory.references.map do |url|
        {
          type: infer_reference_type(url),
          url: url
        }
      end
    end

    def infer_reference_type(url)
      case url.downcase
      when /advisory|security|vuln/i then 'ADVISORY'
      when /fix|commit|pull|pr|patch/i then 'FIX'
      when /github\.com\/[^\/]+\/[^\/]+$/i then 'PACKAGE'
      when /report|disclosure/i then 'REPORT'
      when /article|blog/i then 'ARTICLE'
      when /cve\.org|nvd\.nist\.gov/i then 'ADVISORY'
      else 'WEB'
      end
    end

    def build_affected
      return [] if advisory.packages.blank?

      advisory.packages.map do |package|
        ecosystem = map_ecosystem(package['ecosystem'])
        {
          package: {
            name: package['package_name'],
            ecosystem: ecosystem
          },
          ranges: build_ranges(package['versions'] || [])
        }
      end
    end

    def build_ranges(versions)
      versions.filter_map do |version|
        range = version['vulnerable_version_range']
        next unless range

        events = parse_range_to_events(range, version['first_patched_version'])
        next if events.empty?

        {
          type: 'ECOSYSTEM',
          events: events
        }
      end
    end

    def parse_range_to_events(range, first_patched)
      events = []

      # Split multiple constraints (e.g., ">= 1.0, < 2.0")
      constraints = range.split(/\s*,\s*/)

      constraints.each do |constraint|
        constraint = constraint.strip

        case constraint
        when /^>=\s*(.+)$/
          events << { introduced: $1.strip }
        when /^>\s*(.+)$/
          events << { introduced: $1.strip }
        when /^<\s*(.+)$/
          events << { fixed: $1.strip }
        when /^<=\s*(.+)$/
          # For <= we can't directly represent "fixed" since fixed is exclusive
          # We include the version as fixed (approximation)
          events << { fixed: $1.strip }
        end
      end

      # Add introduced: "0" if only a fixed constraint exists
      if events.any? { |e| e.key?(:fixed) } && events.none? { |e| e.key?(:introduced) }
        events.unshift({ introduced: '0' })
      end

      # Use first_patched_version if available and no fixed event yet
      if first_patched.present? && events.none? { |e| e.key?(:fixed) }
        events << { fixed: first_patched }
      end

      events
    end

    def build_severity
      [
        {
          type: detect_cvss_version(advisory.cvss_vector),
          score: advisory.cvss_vector
        }
      ]
    end

    def detect_cvss_version(vector)
      return 'CVSS_V4' if vector&.start_with?('CVSS:4')
      return 'CVSS_V3' if vector&.start_with?('CVSS:3')
      'CVSS_V3' # Default to V3
    end

    def build_database_specific
      {
        source: advisory.source_kind,
        url: advisory.url,
        severity: advisory.severity,
        cvss_score: advisory.cvss_score,
        epss_percentage: advisory.epss_percentage,
        epss_percentile: advisory.epss_percentile,
        blast_radius: advisory.blast_radius
      }.compact
    end

    def map_ecosystem(ecosystem)
      return nil if ecosystem.blank?
      ECOSYSTEM_MAPPING[ecosystem.downcase] || ecosystem
    end

    def format_timestamp(timestamp)
      return nil if timestamp.blank?
      timestamp.utc.iso8601
    end
  end
end
